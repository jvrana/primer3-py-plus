

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>primer3plus.design &mdash; primer3plus 1.0.9 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> primer3plus
          

          
          </a>

          
            
            
              <div class="version">
                1.0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/changelog.html">primer3plus change log</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">primer3plus</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>primer3plus.design</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for primer3plus.design</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;Core design modules.

For examples for how to use the design module, see the :doc:`Usage Docs &lt;../usage&gt;`
For a list of design parameters available, take a look at the
:ref:`BoulderIO Parameters &lt;api_default_parameters&gt;`

.. code-block:: python

    # a new task
    design = Design()

    # set template sequence
    design.settings.template(&quot;AGGTTGCGTGTGTATGGTCGTGTAGTGTGT&quot;)

    # set left primer sequence
    design.settings.left_sequence(&quot;GTTGCGTGTGT)

    # set as a cloning task
    design.settings.as_cloning_task()

    # run the design task
    design.run()
&quot;&quot;&quot;
import re
import webbrowser
from typing import Any
from typing import Dict
from typing import List
from typing import Tuple
from typing import Union
from warnings import warn

import primer3

from .interfaces import AllParameters
from .interfaces import ParameterAccessor
from .results import parse_primer3_results
from primer3plus.constants import DOCURL
from primer3plus.exceptions import Primer3PlusException
from primer3plus.exceptions import Primer3PlusRunTimeError
from primer3plus.exceptions import Primer3PlusWarning
from primer3plus.log import logger
from primer3plus.params import BoulderIO
from primer3plus.params import default_boulderio
from primer3plus.utils import anneal as anneal_primer
from primer3plus.utils import depreciated_warning


<div class="viewcode-block" id="DesignPresets"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets">[docs]</a>class DesignPresets:
    &quot;&quot;&quot;Interface for setting design parameters. This is typically accessed from
    a :class:`Design &lt;primer3plus.Design&gt;` instance&#39;s.

    :meth:`Design &lt;primer3plus.Design.set&gt;` method. As in:

    .. code-block::

        design = Design()
        design.settings.left_sequence(&quot;AGGGAGATAGATA&quot;)
        design.run()
    &quot;&quot;&quot;

    def __init__(self, design):
        &quot;&quot;&quot;Initializes a new interface from a.

        :class:`~primer3plus.design.Design`.

        :param design: The design
        &quot;&quot;&quot;
        self._design = design

    def _resolve(self):
        &quot;&quot;&quot;Process any extra parameters and process BoulderIO so that it is
        digestable by primer3.&quot;&quot;&quot;
        if self._design.PRIMER_USE_OVERHANGS.value:
            self._resolve_overhangs(self._design.PRIMER_MIN_ANNEAL_CHECK.value)
        if self._design.PRIMER_LONG_OK.value:
            self._resolve_max_lengths(lim=BoulderIO.PRIMER_MAX_SIZE_HARD_LIM)
            self._resolve_product_sizes()
        if not self._design.PRIMER_USE_OVERHANGS.value:
            if self._design.SEQUENCE_PRIMER_OVERHANG.value:
                warn(
                    Primer3PlusWarning(
                        &quot;{} is non-empty (value={}) but {} was False. Overhang was&quot;
                        &quot; ignored&quot;.format(
                            self._design.SEQUENCE_PRIMER_OVERHANG.name,
                            self._design.SEQUENCE_PRIMER_OVERHANG.value,
                            self._design.PRIMER_USE_OVERHANGS.name,
                        )
                    )
                )
            if self._design.SEQUENCE_PRIMER_REVCOMP_OVERHANG.value:
                warn(
                    Primer3PlusWarning(
                        &quot;{} is non-empty (value={}) but {} was False. Overhang was&quot;
                        &quot; ignored&quot;.format(
                            self._design.SEQUENCE_PRIMER_REVCOMP_OVERHANG.name,
                            self._design.SEQUENCE_PRIMER_REVCOMP_OVERHANG.value,
                            self._design.PRIMER_USE_OVERHANGS.name,
                        )
                    )
                )
        return self

    def _post_parse(self, pairs, explain) -&gt; None:
        &quot;&quot;&quot;Modify results from design parameters (e.g. overhangs)&quot;&quot;&quot;
        left_long_overhang = self._design._SEQUENCE_LONG_OVERHANG.value
        right_long_overhang = self._design._SEQUENCE_REVCOMP_LONG_OVERHANG.value

        for pair in pairs.values():
            for x in [&quot;LEFT&quot;, &quot;RIGHT&quot;]:
                pair[x].setdefault(&quot;OVERHANG&quot;, &quot;&quot;)
            if self._design.PRIMER_USE_OVERHANGS:
                pair[&quot;LEFT&quot;][&quot;OVERHANG&quot;] = self._design.SEQUENCE_PRIMER_OVERHANG.value
                pair[&quot;RIGHT&quot;][
                    &quot;OVERHANG&quot;
                ] = self._design.SEQUENCE_PRIMER_REVCOMP_OVERHANG.value
                if left_long_overhang:
                    pair[&quot;LEFT&quot;][&quot;SEQUENCE&quot;] = (
                        left_long_overhang + pair[&quot;LEFT&quot;][&quot;SEQUENCE&quot;]
                    )
                    pair[&quot;LEFT&quot;][&quot;OVERHANG&quot;] = pair[&quot;LEFT&quot;][&quot;OVERHANG&quot;][
                        : -len(left_long_overhang)
                    ]
                    pair[&quot;PAIR&quot;][&quot;PRODUCT_SIZE&quot;] += len(left_long_overhang)
                    loc = pair[&quot;LEFT&quot;][&quot;location&quot;]
                    pair[&quot;LEFT&quot;][&quot;location&quot;] = [
                        loc[0] - len(left_long_overhang),
                        len(pair[&quot;LEFT&quot;][&quot;SEQUENCE&quot;]),
                    ]

                if right_long_overhang:
                    pair[&quot;RIGHT&quot;][&quot;SEQUENCE&quot;] = (
                        right_long_overhang + pair[&quot;RIGHT&quot;][&quot;SEQUENCE&quot;]
                    )
                    pair[&quot;RIGHT&quot;][&quot;OVERHANG&quot;] = pair[&quot;RIGHT&quot;][&quot;OVERHANG&quot;][
                        : -len(right_long_overhang)
                    ]
                    pair[&quot;PAIR&quot;][&quot;PRODUCT_SIZE&quot;] += len(right_long_overhang)
                    loc = pair[&quot;RIGHT&quot;][&quot;location&quot;]
                    pair[&quot;RIGHT&quot;][&quot;location&quot;] = [
                        loc[0] + len(right_long_overhang),
                        len(pair[&quot;RIGHT&quot;][&quot;SEQUENCE&quot;]),
                    ]

    def _interval_from_sequences(
        self, template: str, target: str
    ) -&gt; Union[None, Tuple[int, int]]:
        if isinstance(target, str):
            matches = self._get_index_of_match(template, target)
            if not matches:
                print(&quot;Target not in template&quot;)
                return None
            if len(matches) &gt; 1:
                print(&quot;More than one target found&quot;)
                return None
            return matches[0]

    @staticmethod
    def _get_index_of_match(template: str, sequence: str) -&gt; List[Tuple[int, int]]:
        matches = []
        for m in re.finditer(sequence, template, re.IGNORECASE):
            matches.append((m.start(0), m.end(0)))
        return matches

<div class="viewcode-block" id="DesignPresets.update"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.update">[docs]</a>    def update(self, update: Dict[str, Any]):
        &quot;&quot;&quot;Update an arbitrary parameter.&quot;&quot;&quot;
        self._design.params.update(update)
        return self</div>

<div class="viewcode-block" id="DesignPresets.task"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.task">[docs]</a>    def task(self, task: str) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;This tag tells primer3 what task to perform.

        http://primer3.ut.ee/primer3web_help.htm#PRIMER_TASK

        :param task: the task name
        :return self
        &quot;&quot;&quot;
        self.update({&quot;PRIMER_TASK&quot;: task})
        return self</div>

<div class="viewcode-block" id="DesignPresets.as_cloning_task"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.as_cloning_task">[docs]</a>    def as_cloning_task(self) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Set the design as a cloning task.

        http://primer3.ut.ee/primer3web_help.htm#PRIMER_TASK

        :return: self
        &quot;&quot;&quot;
        return self.task(&quot;pick_cloning_primers&quot;)</div>

<div class="viewcode-block" id="DesignPresets.as_generic_task"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.as_generic_task">[docs]</a>    def as_generic_task(self) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Set the design as a generic task.

        http://primer3.ut.ee/primer3web_help.htm#PRIMER_TASK

        :return: self
        &quot;&quot;&quot;
        return self.task(&quot;generic&quot;)</div>

<div class="viewcode-block" id="DesignPresets.template"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.template">[docs]</a>    def template(self, template: str) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Set the template sequence for the design. This sets the
        &#39;SEQUENCE_TEMPLATE&#39; parameter.

        http://primer3.ut.ee/primer3web_help.htm#SEQUENCE_TEMPLATE

        :param template: the template sequence
        :return: self
        &quot;&quot;&quot;
        self.update({&quot;SEQUENCE_TEMPLATE&quot;: template})
        return self</div>

    # TODO: set_iterations, set_num_return, set_force_return, set_gradient
<div class="viewcode-block" id="DesignPresets.primer_num_return"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.primer_num_return">[docs]</a>    def primer_num_return(self, n: int) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Set the number of primers to return for the design task.

        http://primer3.ut.ee/primer3web_help.htm#PRIMER_NUM_RETURN

        :param n: number of primers to return
        :return: self
        &quot;&quot;&quot;
        return self.update({&quot;PRIMER_NUM_RETURN&quot;: n})</div>

<div class="viewcode-block" id="DesignPresets.product_size"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.product_size">[docs]</a>    def product_size(
        self, interval: Union[Tuple[int, int], List[Tuple[int, int]]], opt=None
    ) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Set the product size. Optionally include the optimal size.

        http://primer3.ut.ee/primer3web_help.htm#PRIMER_PRODUCT_SIZE_RANGE
        http://primer3.ut.ee/primer3web_help.htm#PRIMER_PRODUCT_OPT_SIZE

        :param interval: a tuple of &lt;min&gt;,&lt;max&gt; or a list of such tuples
        :param opt: optional product size as an int.
        :return: self
        &quot;&quot;&quot;
        if isinstance(interval, tuple):
            interval = [interval]
        if opt is not None:
            return self.update(
                {&quot;PRIMER_PRODUCT_SIZE_RANGE&quot;: interval, &quot;PRIMER_PRODUCT_OPT_SIZE&quot;: opt}
            )
        return self.update({&quot;PRIMER_PRODUCT_SIZE_RANGE&quot;: interval})</div>

<div class="viewcode-block" id="DesignPresets.pair_region_list"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.pair_region_list">[docs]</a>    def pair_region_list(
        self, region_list: List[Tuple[int, int, int, int]]
    ) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;The list of regions from which to design primers.

        http://primer3.ut.ee/primer3web_help.htm#SEQUENCE_PRIMER_PAIR_OK_REGION_LIST

        :param region_list: list of regions
        :return: self
        &quot;&quot;&quot;
        return self.update({&quot;SEQUENCE_PRIMER_PAIR_OK_REGION_LIST&quot;: region_list})</div>

<div class="viewcode-block" id="DesignPresets.left_sequence"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.left_sequence">[docs]</a>    def left_sequence(self, primer: str) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;The sequence of a left primer to check and around which to design
        right primers and optional internal oligos. Must be a substring of
        SEQUENCE_TEMPLATE.

        http://primer3.ut.ee/primer3web_help.htm#SEQUENCE_PRIMER
        http://primer3.ut.ee/primer3web_help.htm#PRIMER_PICK_RIGHT_PRIMER

        :param primer: the primer sequence
        :return: self
        &quot;&quot;&quot;

        return self.update({&quot;SEQUENCE_PRIMER&quot;: primer, &quot;PRIMER_PICK_RIGHT_PRIMER&quot;: 1})</div>

<div class="viewcode-block" id="DesignPresets.right_sequence"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.right_sequence">[docs]</a>    def right_sequence(self, primer: str) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;The sequence of a right primer to check and around which to design
        left primers and optional internal oligos. Must be a substring of the
        reverse strand of SEQUENCE_TEMPLATE.

        http://primer3.ut.ee/primer3web_help.htm#SEQUENCE_PRIMER_REVCOMP
        http://primer3.ut.ee/primer3web_help.htm#PRIMER_PICK_LEFT_PRIMER

        :param primer: the primer sequence
        :return: self
        &quot;&quot;&quot;
        return self.update(
            {&quot;SEQUENCE_PRIMER_REVCOMP&quot;: primer, &quot;PRIMER_PICK_LEFT_PRIMER&quot;: 1}
        )</div>

    @staticmethod
    def _trim_long(overhang: str, anneal: str, lim: int) -&gt; Tuple[str, str, str]:
        &quot;&quot;&quot;Fix the overhang and anneal from the hardcoded BoulderIO primer
        lim.&quot;&quot;&quot;
        return overhang, anneal[:-lim], anneal[-lim:]

    def _get_left_overhang(self, min_primer_anneal: int):
        left = self._design.SEQUENCE_PRIMER.value
        if left:
            fwd, _ = anneal_primer(
                self._design.SEQUENCE_TEMPLATE.value, [left], n_bases=min_primer_anneal
            )
            if len(fwd) == 0:
                raise Primer3PlusRunTimeError(&quot;No annealing found for left sequence.&quot;)
            elif len(fwd) &gt; 1:
                raise Primer3PlusRunTimeError(
                    &quot;More than one annealing found for left sequence.&quot;
                )
            overhang = fwd[0][&quot;overhang&quot;]
            anneal = fwd[0][&quot;anneal&quot;]
            return overhang, anneal
        else:
            return &quot;&quot;, left

    def _get_right_overhang(self, min_primer_anneal: int):
        right = self._design.SEQUENCE_PRIMER_REVCOMP.value
        if right:
            _, rev = anneal_primer(
                self._design.SEQUENCE_TEMPLATE.value, [right], n_bases=min_primer_anneal
            )
            if len(rev) == 0:
                raise Primer3PlusRunTimeError(&quot;No annealing found for right sequence.&quot;)
            elif len(rev) &gt; 1:
                raise Primer3PlusRunTimeError(
                    &quot;More than one annealing found for right &quot;
                    &quot;sequence {}.&quot;.format(self._design.SEQUENCE_PRIMER_REVCOMP)
                )
            overhang = rev[0][&quot;overhang&quot;]
            anneal = rev[0][&quot;anneal&quot;]
            return overhang, anneal
        else:
            return &quot;&quot;, right

<div class="viewcode-block" id="DesignPresets.left_overhang"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.left_overhang">[docs]</a>    def left_overhang(self, overhang: str) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Sets the left overhang sequence for the primer. This overhang will.

        *always* be in the overhang sequence regardless of other parameters.

        If using a primer that anneals with an overhang, this value will
        be appended to the 5&#39; end of the overhang.

        :param overhang: overhang sequence
        :return: self
        &quot;&quot;&quot;
        return self.update({&quot;SEQUENCE_PRIMER_OVERHANG&quot;: overhang})</div>

<div class="viewcode-block" id="DesignPresets.right_overhang"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.right_overhang">[docs]</a>    def right_overhang(self, overhang: str) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Sets the right overhang sequence for the primer. This overhang will.

        *always* be in the overhang sequence regardless of other parameters.

        If using a primer that anneals with an overhang, this value will
        be appended to the 5&#39; end of the overhang.

        :param overhang: overhang sequence
        :return: self
        &quot;&quot;&quot;
        return self.update({&quot;SEQUENCE_PRIMER_REVCOMP_OVERHANG&quot;: overhang})</div>

<div class="viewcode-block" id="DesignPresets.use_overhangs"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.use_overhangs">[docs]</a>    def use_overhangs(self, b: bool = True) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Set the BoulderIO to process overhangs.

        :param b: boolean to set
           :return: self
        &quot;&quot;&quot;
        return self.update({&quot;PRIMER_USE_OVERHANGS&quot;: b})</div>

<div class="viewcode-block" id="DesignPresets.long_ok"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.long_ok">[docs]</a>    def long_ok(self, b: bool = True) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Set the BoulderIO to process long primers.

        :param b: boolean to set
        :return: self
        &quot;&quot;&quot;
        return self.update({&quot;PRIMER_LONG_OK&quot;: b})</div>

    def _resolve_product_sizes(self):
        &quot;&quot;&quot;If there are long primers being used, the product_size is no longer
        valid as the trimmed sequence is no longer represented in the
        originally provided product size.

        This re-adjusts the product size to correspond the adjusted
        parameters.
        &quot;&quot;&quot;
        # adjust product size range
        left_long_overhang = self._design._SEQUENCE_LONG_OVERHANG.value
        right_long_overhang = self._design._SEQUENCE_REVCOMP_LONG_OVERHANG.value
        product_sizes = self._design.PRIMER_PRODUCT_SIZE_RANGE.value

        x = len(left_long_overhang) + len(right_long_overhang)

        if isinstance(product_sizes[0], tuple):
            new_product_sizes = []
            for size in product_sizes:
                new_product_sizes.append((size[0] - x, size[1] - x))
            self._design.PRIMER_PRODUCT_SIZE_RANGE.value = new_product_sizes
        else:
            size = self._design.PRIMER_PRODUCT_SIZE_RANGE.value
            self._design.PRIMER_PRODUCT_SIZE_RANGE.value = [size[0] - x, size[1] - x]

    def _resolve_max_lengths(self, lim: int):
        &quot;&quot;&quot;Fixes the annealing and overhang sequences for annealing sequences
        for primers over the :attr:`BoulderIO.

        &lt;primer3plus.paramsBoulderIO.PRIMER_MAX_SIZE_HARD_LIM&gt;`.
        Should always be run *after* :meth:`_resolve_overhangs`.
        &quot;&quot;&quot;
        left_anneal = self._design.SEQUENCE_PRIMER.value
        right_anneal = self._design.SEQUENCE_PRIMER_REVCOMP.value
        left_over = self._design.SEQUENCE_PRIMER_OVERHANG.value
        right_over = self._design.SEQUENCE_PRIMER_REVCOMP_OVERHANG.value

        left_over, left_long_overhang, left_anneal = self._trim_long(
            left_over, left_anneal, lim=lim
        )
        right_over, right_long_overhang, right_anneal = self._trim_long(
            right_over, right_anneal, lim=lim
        )

        self.left_overhang(left_over + left_long_overhang)
        self.right_overhang(right_over + right_long_overhang)

        # save the sequences that were trimmed
        # TODO: will need to re-add these in the results in overhang, product size, and anneal
        # TODO: adjust the product_size
        # TODO: adjust any other regions
        # TODO: re-adjust tm and add any warnings

        # save values for long overhangs
        self._left_long_overhang(left_long_overhang)
        self._right_long_overhang(right_long_overhang)

        self.left_sequence(left_anneal)
        self.right_sequence(right_anneal)

    def _left_long_overhang(self, x):
        self.update({&quot;_SEQUENCE_LONG_OVERHANG&quot;: x})

    def _right_long_overhang(self, x):
        self.update({&quot;_SEQUENCE_REVCOMP_LONG_OVERHANG&quot;: x})

    def _resolve_overhangs(self, min_primer_anneal: int):
        &quot;&quot;&quot;Sets the annealing and overhang sequences.&quot;&quot;&quot;
        left_over, left_anneal = self._get_left_overhang(min_primer_anneal)
        _loverhang = self._design.SEQUENCE_PRIMER_OVERHANG.value
        if _loverhang:
            left_over = _loverhang + left_over
            # raise ValueError(
            #     &quot;Left overhang already set to &#39;{}&#39;.&quot;.format(_loverhang)
            # )

        right_over, right_anneal = self._get_right_overhang(min_primer_anneal)
        _roverhang = self._design.SEQUENCE_PRIMER_REVCOMP_OVERHANG.value
        if _roverhang:
            right_over = _roverhang + right_over
            # raise ValueError(
            #     &quot;Right overhang already set to &#39;{}&#39;.&quot;.format(_roverhang)
            # )

        self.left_overhang(left_over)
        self.right_overhang(right_over)
        self.left_sequence(left_anneal)
        self.right_sequence(right_anneal)

<div class="viewcode-block" id="DesignPresets.pick_left_only"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.pick_left_only">[docs]</a>    def pick_left_only(self) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Design only the left primer.

        http://primer3.ut.ee/primer3web_help.htm#PRIMER_PICK_LEFT_PRIMER
        http://primer3.ut.ee/primer3web_help.htm#PRIMER_PICK_RIGHT_PRIMER

        :return: self
        &quot;&quot;&quot;
        return self.update(
            {&quot;PRIMER_PICK_LEFT_PRIMER&quot;: 1, &quot;PRIMER_PICK_RIGHT_PRIMER&quot;: 0}
        )</div>

<div class="viewcode-block" id="DesignPresets.pick_right_only"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.pick_right_only">[docs]</a>    def pick_right_only(self) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Design only the right primer.

        http://primer3.ut.ee/primer3web_help.htm#PRIMER_PICK_LEFT_PRIMER
        http://primer3.ut.ee/primer3web_help.htm#PRIMER_PICK_RIGHT_PRIMER

        :return: self
        &quot;&quot;&quot;
        return self.update(
            {&quot;PRIMER_PICK_LEFT_PRIMER&quot;: 0, &quot;PRIMER_PICK_RIGHT_PRIMER&quot;: 1}
        )</div>

<div class="viewcode-block" id="DesignPresets.internal_sequence"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.internal_sequence">[docs]</a>    def internal_sequence(self, primer: str) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;The sequence of an internal oligo to check and around which to
        design left and right primers. Must be a substring of
        SEQUENCE_TEMPLATE.

        http://primer3.ut.ee/primer3web_help.htm#SEQUENCE_INTERNAL_OLIGO
        http://primer3.ut.ee/primer3web_help.htm#PRIMER_PICK_INTERNAL_OLIGO


        :param primer: :type primer: :return: :rtype:
        &quot;&quot;&quot;
        return self.update(
            {&quot;SEQUENCE_INTERNAL_OLIGO&quot;: primer, &quot;PRIMER_PICK_INTERNAL_OLIGO&quot;: 1}
        )</div>

<div class="viewcode-block" id="DesignPresets.primers"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.primers">[docs]</a>    def primers(self, p1: str, p2: str) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Set the left and right primer sequences.

        http://primer3.ut.ee/primer3web_help.htm#SEQUENCE_PRIMER
        http://primer3.ut.ee/primer3web_help.htm#PRIMER_PICK_RIGHT_PRIMER
        http://primer3.ut.ee/primer3web_help.htm#SEQUENCE_PRIMER_REVCOMP
        http://primer3.ut.ee/primer3web_help.htm#PRIMER_PICK_LEFT_PRIMER

        :param p1:
        :param p2:
        :return:
        &quot;&quot;&quot;
        if p1:
            self.left_sequence(p1)
        if p2:
            self.right_sequence(p2)
        return self</div>

    def primers_with_overhangs(self, p1: str, p2: str) -&gt; &quot;DesignPresets&quot;:
        if p1:
            self.left_sequence_with_overhang(p1)
        if p2:
            self.right_sequence_with_overhang(p2)
        return self

    def _parse_interval(
        self, interval: Union[str, Tuple[int, int], List[Tuple[int, int]]]
    ) -&gt; List[Tuple[int, int]]:
        if isinstance(interval, str):
            interval = self._interval_from_sequences(
                self._design.params[&quot;SEQUENCE_TEMPLATE&quot;], interval
            )
        if isinstance(interval, tuple):
            interval = [interval]
        return interval

<div class="viewcode-block" id="DesignPresets.included"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.included">[docs]</a>    def included(self, interval: Union[str, Tuple[int, int]]) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Specify interval from which primers must be selected. A sub-region
        of the given sequence in which to pick primers. For example, often the
        first dozen or so bases of a sequence are vector, and should be
        excluded from consideration. The value for this parameter has the form.

        http://primer3.ut.ee/primer3web_help.htm#SEQUENCE_INCLUDED_REGION

        &lt;start&gt;,&lt;length&gt; where &lt;start&gt; is the index of the first base to consider, and
        &lt;length&gt; is the number of subsequent bases in the primer-picking region.

        :param interval: One of the following: the sequence of the target region,
                         a tuple of the interval of &lt;start&gt;,&lt;length&gt; or a str
        :return: self
        &quot;&quot;&quot;
        if isinstance(interval, str):
            interval = self._interval_from_sequences(
                self._design.params[&quot;SEQUENCE_TEMPLATE&quot;], interval
            )
        if not len(interval) == 2 or (
            not isinstance(interval, tuple) and not isinstance(interval, list)
        ):
            raise TypeError(
                &quot;Expect an tuple or list of length 2 but found {}&quot;.format(interval)
            )
        interval = list(interval)
        return self.update({&quot;SEQUENCE_INCLUDED_REGION&quot;: interval})</div>

<div class="viewcode-block" id="DesignPresets.target"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.target">[docs]</a>    def target(
        self, interval: Union[str, Tuple[int, int], List[Tuple[int, int]]]
    ) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Specify the interval that designed primers must flank. If one or
        more targets is specified then a legal primer pair must flank at least
        one of them. A target might be a simple sequence repeat site (for
        example a CA repeat) or a single-base-pair polymorphism, or an exon for
        resequencing. The value should be a space-separated list of.

        &lt;start&gt;,&lt;length&gt; pairs where &lt;start&gt; is the index of the first base of
        a target,and &lt;length&gt; is its length.  See also PRIMER_INSIDE_PENALTY,
        PRIMER_OUTSIDE_PENALTY. PRIMER_TASK=pick_sequencing_primers. See
        PRIMER_TASK for more information.

        http://primer3.ut.ee/primer3web_help.htm#SEQUENCE_TEMPLATE
        http://primer3.ut.ee/primer3web_help.htm#SEQUENCE_TARGET


        :param interval: One of the following: the sequence of the target region,
                         a tuple of the interval of &lt;start&gt;,&lt;length&gt;, or a list of
                         tuples of &lt;start&gt;,&lt;length&gt;
        :return self
        &quot;&quot;&quot;
        return self.update({&quot;SEQUENCE_TARGET&quot;: self._parse_interval(interval)})</div>

<div class="viewcode-block" id="DesignPresets.excluded"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.excluded">[docs]</a>    def excluded(
        self, interval: Union[str, Tuple[int, int], List[Tuple[int, int]]]
    ) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Primers and oligos may not overlap any region specified in this tag.
        The associated value must be a space-separated list of &lt;start&gt;,&lt;length&gt;
        pairs where &lt;start&gt; is the index of the first base of the excluded
        region, and &lt;length&gt; is its length. This tag is useful for tasks such
        as excluding regions of low sequence quality or for excluding regions
        containing repetitive elements such as ALUs or LINEs.

        http://primer3.ut.ee/primer3web_help.htm#SEQUENCE_TEMPLATE
        http://primer3.ut.ee/primer3web_help.htm#SEQUENCE_EXCLUDED_REGION

        :param interval: One of the following: the sequence of the target region,
                         a tuple of the interval of &lt;start&gt;,&lt;length&gt;, or a list of
                         tuples of &lt;start&gt;,&lt;length&gt;
        :return: self
        &quot;&quot;&quot;
        return self.update({&quot;SEQUENCE_EXCLUDED_REGION&quot;: self._parse_interval(interval)})</div>

<div class="viewcode-block" id="DesignPresets.pick_anyway"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignPresets.pick_anyway">[docs]</a>    def pick_anyway(self, b=1) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;If true use primer provided in SEQUENCE_PRIMER,
        SEQUENCE_PRIMER_REVCOMP, or SEQUENCE_INTERNAL_OLIGO even if it violates
        specific constraints.

        http://primer3.ut.ee/primer3web_help.htm#PRIMER_PICK_ANYWAY

        :param b: default True
        :return self
        &quot;&quot;&quot;
        return self.update({&quot;PRIMER_PICK_ANYWAY&quot;: b})</div></div>


def clip(x, mn, mx):
    return max(min(x, mx), mn)


<div class="viewcode-block" id="DesignBase"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignBase">[docs]</a>class DesignBase:
    &quot;&quot;&quot;Base design.&quot;&quot;&quot;

    DEFAULT_PARAMS = default_boulderio  #: default parameters
    DEFAULT_GRADIENT = dict(
        PRIMER_MAX_SIZE=(1, DEFAULT_PARAMS[&quot;PRIMER_MAX_SIZE&quot;], 36),
        PRIMER_MIN_SIZE=(-1, 16, DEFAULT_PARAMS[&quot;PRIMER_MAX_SIZE&quot;]),
        PRIMER_MAX_TM=(1, DEFAULT_PARAMS[&quot;PRIMER_MAX_SIZE&quot;], 80),
        PRIMER_MIN_TM=(-1, 48, DEFAULT_PARAMS[&quot;PRIMER_MIN_TM&quot;]),
        PRIMER_MAX_HAIRPIN_TH=(1, DEFAULT_PARAMS[&quot;PRIMER_MAX_HAIRPIN_TH&quot;], 60),
    )  #: the default gradient to use for the :meth:`Design.run_and_optimize` method.
    _CHECK_PRIMERS = &quot;check_primers&quot;
    _GENERIC = &quot;generic&quot;
    _PICK_PRIMER_LIST = &quot;pick_primer_list&quot;
    _PICK_SEQUENCING_PRIMERS = &quot;pick_sequencing_primers&quot;
    _PICK_CLONING_PRIMERS = &quot;pick_cloning_primers&quot;
    _PICK_DISCRIMINATIVE_PRIMERS = &quot;pick_discriminative_primers&quot;

    def __init__(
        self,
        gradient: Dict[
            str, Tuple[Union[float, int], Union[float, int], Union[float, int]]
        ] = None,
        params: BoulderIO = None,
        quiet_runtime: bool = False,
    ):
        &quot;&quot;&quot;Initializes a new design.

        :param gradient: the design gradient.
        :param quiet_runtime: if True will siliently ignore any runtime errors.
        &quot;&quot;&quot;
        if params is None:
            params = self.DEFAULT_PARAMS.copy()
        self.params = params
        self.logger = logger(self)
        self.gradient = gradient
        self.quiet_runtime = quiet_runtime

    def _raise_run_time_error(self, msg: str) -&gt; Primer3PlusRunTimeError:
        &quot;&quot;&quot;Raise a Primer3PlusRunTime exception. If parameters are named in the
        msg, print off some debugging information at the end of the message.

        :param msg: the error msg
        :return: the run time exception
        &quot;&quot;&quot;
        parameter_explain = set()
        for name, value in self.params._params.items():
            if name in msg:
                parameter_explain.add(&quot;\t&quot; + str(value))
        parameter_explain = sorted(parameter_explain)
        return Primer3PlusRunTimeError(msg + &quot;\n&quot; + &quot;\n&quot;.join(parameter_explain))

    def _run(self, params: BoulderIO = None) -&gt; Tuple[List[Dict], List[Dict]]:
        &quot;&quot;&quot;Design primers. Optionally provide additional parameters.

        :param params:
        :return: results
        &quot;&quot;&quot;
        if params is None:
            params = self.params
        try:
            res = primer3.bindings.designPrimers(params._sequence(), params._globals())
        except OSError as e:
            if not self.quiet_runtime:
                raise self._raise_run_time_error(str(e)) from e
            else:
                return {}, {&quot;PRIMER_ERROR&quot;: str(e)}
        except Primer3PlusRunTimeError as e:
            if not self.quiet_runtime:
                raise self._raise_run_time_error(str(e)) from e
            else:
                return {}, {&quot;PRIMER_ERROR&quot;: str(e)}
        except Primer3PlusException as e:
            raise self._raise_run_time_error(str(e)) from e

        pairs, explain = parse_primer3_results(res)
        self.settings._post_parse(pairs, explain)
        return pairs, explain

<div class="viewcode-block" id="DesignBase.run"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignBase.run">[docs]</a>    def run(self) -&gt; Tuple[List[Dict], List[Dict]]:
        &quot;&quot;&quot;Design primers. Optionally provide additional parameters.

        :param params:
        :return: results
        &quot;&quot;&quot;
        return self._run()</div>

<div class="viewcode-block" id="DesignBase.run_and_optimize"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignBase.run_and_optimize">[docs]</a>    def run_and_optimize(
        self,
        max_iterations,
        params: BoulderIO = None,
        gradient: Dict[
            str, Tuple[Union[float, int], Union[float, int], Union[float, int]]
        ] = None,
        run_kwargs: dict = None,
    ) -&gt; Tuple[List[dict], List[dict]]:
        &quot;&quot;&quot;Design primers and relax constraints. If primer design is
        unsuccessful, relax parameters as defined in
        primer3plust.Design.DEFAULT_GRADIENT. Repeat for the specified number
        of max_iterations.

        :param max_iterations: the max number of iterations to perform relaxation
        :param params: optional parameters to provide
        :param gradient: optional gradient to provide. If not provided,
                            Design.DEFAULT_GRADIENT will be used. The gradient is a
                            dictionary off 3 tuples, the step the min and the max.
        :return: results
        &quot;&quot;&quot;
        if gradient is None:
            gradient = self.gradient or self.DEFAULT_GRADIENT
        if params is None:
            params = self.params
        pairs, explain = self._run(params)
        i = 0
        while i &lt; max_iterations and len(pairs) == 0:
            i += 1
            update = self._update_dict(params, gradient=gradient)
            if update:
                self.logger.info(&quot;Updated: {}&quot;.format(update))
            else:
                self.logger.info(&quot;Reached end of gradient.&quot;)
                break
            self.params.update(update)
            pairs, explain = self._run(params)
        return pairs, explain</div>

    @staticmethod
    def _update_dict(params, gradient):
        update = {}
        for param_key, gradient_tuple in gradient.items():
            delta, mn, mx = gradient_tuple
            try:
                val = params[param_key] + delta
                val = clip(val, mn, mx)
                if params[param_key] != val:
                    update[param_key] = val
            except Exception as e:
                raise e
        return update

<div class="viewcode-block" id="DesignBase.open_help"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignBase.open_help">[docs]</a>    @staticmethod
    def open_help():
        &quot;&quot;&quot;Open the documentation help in a new browser tab.&quot;&quot;&quot;
        webbrowser.open(DOCURL)</div>

<div class="viewcode-block" id="DesignBase.copy"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.DesignBase.copy">[docs]</a>    def copy(self):
        &quot;&quot;&quot;Copy this design and its parameters.&quot;&quot;&quot;
        designer = self.__class__()
        designer.params = self.params.copy()</div>

    def __copy__(self):
        return self.copy()</div>


<div class="viewcode-block" id="RestoreAfterRun"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.RestoreAfterRun">[docs]</a>class RestoreAfterRun:
    &quot;&quot;&quot;Class to restore boulderio to its original parameters after a run.&quot;&quot;&quot;

    def __init__(self, boulderio):
        self.params = boulderio

    def __enter__(self):
        for v in self.params._params.values():
            v.hold_restore()

    def __exit__(self, a, b, c):
        for v in self.params._params.values():
            v.restore()</div>


<div class="viewcode-block" id="Design"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.Design">[docs]</a>class Design(DesignBase, AllParameters):
    def __init__(self):
        &quot;&quot;&quot;Initialize a new design. Set parameters using.

        :attr:`Design.settings`, which
        returns an instance of
        :class:`DesignPresets &lt;primer3plus.design.DesignPresets&gt;`.

        Alternatively, parameters can be accessed more directly using
        the name of the parameter descriptor. For a list of parameters available, see
        :ref:`BoulderIO Parameters &lt;api_default_parameters&gt;`.

        .. code-block::

            design = Design()
            design.settings.template(&quot;AGGCTGTAGTGCTTGTAGCTGGTTGCGTTACTGTG&quot;)
            design.settings.left_sequence(&quot;GTAGTGCTTGTA&quot;)
            design.SEQUENCE_ID.value = &quot;MY ID&quot;
            design.run()
        &quot;&quot;&quot;
        super().__init__()
        self._settings = DesignPresets(self)

    def set(self, key, value):
        self.params.defs[key].value = value

    def get(self, key):
        return self.params.defs[key]

    @property
    def settings(self) -&gt; &quot;DesignPresets&quot;:
        &quot;&quot;&quot;Return the :class:`DesignPresets &lt;primer3plus.design.DesignPresets&gt;`
        instance for this design.&quot;&quot;&quot;
        return self._settings

    @property
    def presets(self):
        depreciated_warning(&quot;&#39;presets&#39; has been renamed to &#39;settings&#39;&quot;)
        return self.settings

<div class="viewcode-block" id="Design.update"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.Design.update">[docs]</a>    def update(self, data: Dict[str, Any]):
        &quot;&quot;&quot;Update an arbitrary parameter.&quot;&quot;&quot;
        return self.params.update(data)</div>

<div class="viewcode-block" id="Design.run"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.Design.run">[docs]</a>    def run(self) -&gt; Tuple[List[Dict], List[Dict]]:
        &quot;&quot;&quot;Design primers. Optionally provide additional parameters.

        :param params:
        :return: results
        &quot;&quot;&quot;
        with RestoreAfterRun(self.params):
            self.settings._resolve()
            return super()._run(None)</div>

<div class="viewcode-block" id="Design.run_and_optimize"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.Design.run_and_optimize">[docs]</a>    def run_and_optimize(
        self,
        max_iterations,
        params: BoulderIO = None,
        gradient: Dict[
            str, Tuple[Union[float, int], Union[float, int], Union[float, int]]
        ] = None,
        pick_anyway: bool = False,
    ) -&gt; Tuple[List[dict], List[dict]]:
        &quot;&quot;&quot;Design primers. If primer design is unsuccessful, relax parameters
        as defined in primer3plust.Design.DEFAULT_GRADIENT. Repeat for the
        specified number of max_iterations.

        :param max_iterations: the max number of iterations to perform relaxation
        :param params: optional parameters to provide
        :param gradient: optional gradient to provide. If not provided,
                            Design.DEFAULT_GRADIENT will be used. The gradient is a
                            dictionary off 3 tuples, the step the min and the max.
        :param pick_anyway: if set to True, if the optimization finds no pairs,
            pick a pair anyways.
        :return: results
        &quot;&quot;&quot;
        with RestoreAfterRun(self.params):
            self.settings._resolve()
            pairs, explain = super().run_and_optimize(max_iterations)
            if pick_anyway and not pairs:
                self.settings.pick_anyway(1)
                pairs, explain = super().run()
            return pairs, explain</div></div>


<div class="viewcode-block" id="new"><a class="viewcode-back" href="../../developer/api_reference.html#primer3plus.design.new">[docs]</a>def new(params=None):
    &quot;&quot;&quot;Start a new design.&quot;&quot;&quot;
    design = Design()
    if params:
        design.params.update(params)</div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017-2019, University of Washington

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>